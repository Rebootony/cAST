{
  "ll1": {
    "start": "translation_unit",
    "rules": [
      "translation_unit := list(external_declaration) -> TranslationUnit( external_declarations=$0 )",
      "external_declaration :=  'external_declaration_hint' + mlist(declaration_specifier, 1) + list(external_declaration_sub, 'comma') -> ExternalDeclaration( declaration_specifiers=$1, declarations=$2)",
      "external_declaration_sub := external_function | external_declarator_list | external_prototype",
      "external_function := 'function_definition_hint' + declarator + optional(declaration_list) + compound_statement -> FunctionDefinition( declaration_specifiers=$1, signature=$2, declaration_list=$3, body=$4)",
      "external_declarator_list := 'declarator_hint' + optional(init_declarator_list) + 'semi' ->  DeclaratorList( init_declarator_list=$1)",
      "external_prototype := 'function_prototype_hint' + declarator + optional(declaration_list) -> FunctionPrototype(declarator=$1, declaration_list=$2)",
      "declaration_list := list(declaration)",
      "declaration := mlist(declaration_specifier, 1) + optional(init_declarator_list) + 'semi' -> Declaration( declaration_specifiers=$0, init_declarators=$1 )",
      "declaration_specifier := storage_class_specifier | type_specifier | type_qualifier | function_specifier",
      "init_declarator_list := list(init_declarator, 'comma', 1)",
      "init_declarator := declarator + optional(declarator_initializer) -> InitDeclarator( declarator=$0, initializer=$1 )",
      "declarator_initializer := 'assign' + initializer -> $1",
      "initializer := _expr",
      "initializer := 'lbrace' + list(initializer_list_item, 'comma', 1) + trailing_comma_opt + 'rbrace' -> $1",
      "initializer_list_item := optional(designation) + initializer",
      "designation := list(designator) + 'assign'",
      "designator := 'lsquare' + _expr + 'rsquare' -> ArrayAccess( index=$1 )",
      "designator := 'dot' + 'identifier' -> MemberAccess( name=$1 )",
      "storage_class_specifier := 'typedef' | 'extern' | 'static' | 'auto' | 'register'",
      "type_specifier := 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | '_Bool' | '_Complex' | struct_specifier | union_specifier | enum_specifier | typedef_name",
      "struct_specifier := 'struct' + struct_or_union_sub -> Struct( definition=$1 )",
      "union_specifier := 'union' + struct_or_union_sub -> Union( definition=$1 )",
      "struct_or_union_sub := 'identifier' + optional(struct_or_union_body) -> StructOrUnion( name=$0, body=$1 )",
      "struct_or_union_sub := struct_or_union_body -> StructOrUnion( body=$0 )",
      "struct_or_union_body := 'lbrace' + list(struct_declaration) + 'rbrace' -> $1",
      "struct_declaration := list(specifier_qualifier) + list(struct_declarator, 'comma', 1) + 'semi' -> StructOrUnionDeclaration( specifier_qualifiers=$0, declarators=$1 )",
      "specifier_qualifier := type_specifier | type_qualifier",
      "struct_declarator := struct_declarator_body",
      "struct_declarator := declarator + optional(struct_declarator_body)",
      "struct_declarator_body := 'colon' + declarator",
      "enum_specifier := 'enum' + enum_specifier_sub",
      "enum_specifier_sub := identifier + optional(enum_specifier_body)",
      "enum_specifier_sub := enum_specifier_body",
      "enum_specifier_body := 'lbrace' + list(enumerator, 'comma', 1) + trailing_comma_opt + 'rbrace'",
      "enumerator := enumeration_constant  + enumerator_assignment",
      "enumerator_assignment := 'assign' + _expr | _empty",
      "enumeration_constant := 'identifier'",
      "typedef_name := 'typedef_identifier'",
      "type_qualifier := 'const' | 'restrict' | 'volatile'",
      "type_qualifier_list_opt := list(type_qualifier) | _empty",
      "function_specifier := 'inline'",
      "declarator := pointer_opt + _direct_declarator -> Declarator( pointer=$0, direct_declarator=$1 )",
      "direct_declarator_expr := direct_declarator_modifier_list_opt + direct_declarator_size | _empty",
      "direct_declarator_modifier_list_opt := list(direct_declarator_modifier) | _empty",
      "direct_declarator_modifier := type_qualifier | 'static'",
      "direct_declarator_size := _expr | 'asterisk'",
      "parameter_type_list := list(parameter_declaration, 'comma', 1) + va_args -> ParameterTypeList( parameter_declarations=$0, va_args=$1 )",
      "parameter_type_list_opt := parameter_type_list | _empty",
      "direct_declarator_parameter_list := parameter_type_list | list(identifier, 'comma') -> ParameterList( identifiers=$0 ) | _empty",
      "identifier := 'identifier'",
      "va_args := 'comma_va_args' + 'elipsis' | _empty",
      "parameter_declaration := mlist(declaration_specifier, 1) + optional(parameter_declaration_sub) -> ParameterDeclaration(declaration_specifiers=$0, sub=$1 )",
      "parameter_declaration_sub := pointer_opt + parameter_declaration_sub_sub -> ParameterSub( pointer=$0, name_and_size=$1 )",
      "parameter_declaration_sub_sub := _direct_declarator | direct_abstract_declarator_opt",
      "abstract_declarator := pointer_opt + direct_abstract_declarator_opt",
      "pointer_opt := pointer | _empty",
      "pointer := list(pointer_sub)",
      "pointer_sub := 'asterisk' + type_qualifier_list_opt",
      "direct_abstract_declarator_opt := _direct_abstract_declarator | _empty",
      "direct_abstract_declarator_expr := type_qualifier_list_opt + static_opt + _expr | 'asterisk' | _empty",
      "expression_opt := _expr | _empty",

      "statement := labeled_statement",
      "statement := compound_statement",
      "statement := expression_statement",
      "statement := selection_statement",
      "statement := iteration_statement",
      "statement := jump_statement",
      "labeled_statement := 'identifier' + 'colon' + statement -> Label( name=$0, statement=$1)",
      "labeled_statement := 'case' + _expr + 'colon' + statement -> Case( expr=$1, statement=$3 )",
      "labeled_statement := 'default' + 'colon' + statement -> DefaultCase( statement=$2 )",
      "compound_statement := 'lbrace' + optional(block_item_list) + 'rbrace' -> $1",
      "block_item_list := list(block_item)",
      "block_item := declaration | statement",
      "expression_statement := expression_opt + 'semi'",
      "selection_statement := 'if' + 'lparen' + _expr + 'rparen' + statement + 'endif' + optional(else_if_statement_list) + optional(else_statement) -> If(condition=$2, statement=$4, elseif=$6, else=$7)",
      "else_if_statement_list := list(else_if_statement)",
      "else_if_statement := 'else_if' + 'lparen' + _expr + 'rparen' + statement + 'endif' -> ElseIf( condition=$2, statement=$4 )",
      "else_statement := 'else' + statement + 'endif' -> Else( statement=$1 )",
      "selection_statement := 'switch' + 'lparen' + _expr + 'rparen' + statement -> Switch( expr=$2, statment=$4 )",
      "iteration_statement := 'while' + 'lparen' + _expr + 'rparen' + statement -> While( expr=$2, statement=$4 )",
      "iteration_statement := 'do' + statement + 'while' + 'lparen' + _expr + 'rparen' + 'semi' -> DoWhile( statement=$1, expr=4 )",
      "iteration_statement := 'for' + 'lparen' + for_init + for_cond + for_incr + 'rparen' + statement -> For( init=$2, cond=$3, incr=$4 )",
      "for_init := declaration + expression_opt | _expr | _empty",
      "for_cond := 'semi' + expression_opt -> $1",
      "for_incr := 'semi' + expression_opt -> $1 | _empty",
      "jump_statement := 'goto' + 'identifier' + 'semi' -> Goto( name=$1 )",
      "jump_statement := 'continue'",
      "jump_statement := 'break' + 'semi'",
      "jump_statement := 'return' + expression_opt + 'semi' -> Return( expr=$1 )",


      "pp := 'defined' | 'defined_separator'",
      "token := keyword | 'identifier' | constant | 'string_literal' | punctuator | 'pp_number'",
      "keyword := 'auto' | 'break' | 'case' | 'char' | 'const' | 'continue' | 'default' | 'do' | 'double' | 'else' | 'enum' | 'extern' | 'float' | 'for' | 'goto' | 'if' | 'inline' | 'int' | 'long' | 'register' | 'restrict' | 'return' | 'short' | 'signed' | 'sizeof' | 'static' | 'struct' | 'switch' | 'typedef' | 'union' | 'unsigned' | 'void' | 'volatile' | 'while' | '_Bool' | '_Complex' | '_Imaginary'",
      "punctuator := 'arrow' | 'dot' | 'lbrace' | 'rbrace' | 'lsquare' | 'rsquare' | 'lparen' | 'rparen' | 'exclamation_point' | 'tilde' | 'sub' | 'add' | 'div' | 'ampersand' | 'decr' | 'incr' | 'or' | 'and' | 'bitor' | 'bitxor' | 'neq' | 'eq' | 'lteq' | 'gteq' | 'lt' | 'gt' | 'lshift' | 'rshift' | 'mod' | 'elipsis' | 'semi' | 'colon' | 'questionmark' | 'bitoreq' | 'bitxoreq' | 'bitandeq' | 'lshifteq' | 'rshifteq' | 'subeq' | 'addeq' | 'modeq' | 'muleq' | 'assign' | 'poundpound' | 'pound' | 'comma'",
      "terminals := 'AUTO' | 'BOOL' | 'BREAK' | 'CASE' | 'CHAR' | 'COMPLEX' | 'CONST' | 'CONTINUE' | 'DEFAULT' | 'DO' | 'DOUBLE' | 'ELSE' | 'ENUM' | 'EXTERN' | 'FLOAT' | 'FOR' | 'GOTO' | 'IF' | 'IMAGINARY' | 'INLINE' | 'INT' | 'LONG' | 'REGISTER' | 'RESTRICT' | 'RETURN' | 'SHORT' | 'SIGNED' | 'SIZEOF' | 'STATIC' | 'STRUCT' | 'SWITCH' | 'TYPEDEF' | 'UNION' | 'UNSIGNED' | 'VOID' | 'VOLATILE' | 'WHILE' | 'POUND' | 'UNIVERSAL_CHARACTER_NAME' | 'LBRACE' | 'RBRACE' | 'POUNDPOUND' | 'ELIPSIS' | 'DOT' | 'QUESTIONMARK' | 'ARROW' | 'LTEQ' | 'GTEQ' | 'LT' | 'GT' | 'SEMI' | 'LPAREN' | 'RPAREN' | 'EQ' | 'NEQ' | 'ASSIGN' | 'LSQUARE' | 'RSQUARE' | 'COMMA' | 'COLON' | 'IDENTIFIER' | 'STRING_LITERAL' | 'NUMBER' | 'INCR' | 'DECR' | 'ADDEQ' | 'SUBEQ' | 'MULEQ' | 'DIVEQ' | 'MODEQ' | 'ADD' | 'SUB' | 'DIV' | 'MOD' | 'AND' | 'OR' | 'BITAND' | 'BITOR' | 'NOT' | 'BITXOR' | 'TILDE' | 'EXCLAMATION_POINT' | 'LSHIFT' | 'RSHIFT' | 'LSHIFTEQ' | 'RSHIFTEQ' | 'BITANDEQ' | 'BITXOREQ' | 'BITOREQ' | 'INTEGER_CONSTANT' | 'HEADER_NAME' | 'DECIMAL_FLOATING_CONSTANT' | 'HEXADECIMAL_FLOATING_CONSTANT' | 'CHARACTER_CONSTANT'",

      "constant := 'integer_constant' | 'floating_constant' | 'enumeration_constant' | 'character_constant'",
      "type_name := 'int' | 'char'",
      "initializer_list_item := 'integer_constant'",
      "trailing_comma_opt := 'trailing_comma' | _empty",
      "static_opt := 'static' | _empty",
      "sizeof_body := 'identifier' | 'lparen' + type_name + 'rparen' -> $1"
    ]

  },
  "expr": [
    {
      "nonterminal": "_expr",
      "binding_power": [
          {"associativity": "left", "terminals": ["comma"]},
          {"associativity": "right", "terminals": ["assign", "addeq", "subeq", "muleq", "diveq", "modeq", "bitoreq", "bitandeq", "bitxoreq", "lshifteq", "rshifteq"]},
          {"associativity": "right", "terminals": ["questionmark"]},
          {"associativity": "left", "terminals": ["or"]},
          {"associativity": "left", "terminals": ["and"]},
          {"associativity": "left", "terminals": ["bitand"]},
          {"associativity": "left", "terminals": ["bitxor"]},
          {"associativity": "left", "terminals": ["bitor"]},
          {"associativity": "right", "terminals": ["eq", "neq"]},
          {"associativity": "left", "terminals": ["lt", "gt", "gteq", "lteq"]},
          {"associativity": "left", "terminals": ["lshift", "rshift"]},
          {"associativity": "left", "terminals": ["add", "sub"]},
          {"associativity": "left", "terminals": ["asterisk", "div", "mod"]},
          {"associativity": "unary", "terminals": ["sub", "incr", "decr", "asterisk", "bitand", "not", "bitnot"]},
          {"associativity": "left", "terminals": ["lbrace"]},
          {"associativity": "left", "terminals": ["lparen", "lsquare", "dot", "arrow", "incr", "decr"]}
      ],
      "rules": [
        "_expr := {'identifier'} + {'lparen' + list(_expr, 'comma') + 'rparen'} -> FuncCall( name=$0, params=$2 )",
        "_expr := {'identifier'} + {'lsquare' + list(_expr, 'comma') + 'rsquare'} -> ArrayIndex( name=$0, params=$2 )",
        "_expr := {'lparen_cast' + type_name + 'rparen'} + {'lbrace' + list(initializer_list_item, 'comma') + trailing_comma_opt + 'rbrace'} -> TypeInitializion( type=$1, initializer=$4 )",
        "_expr := {_expr} + {'dot' + _expr} -> MemberSelect( object=$0, member=$2 )",
        "_expr := {_expr} + {'arrow' + _expr} -> DerefMemberSelect( object=$0, member=$2 )",
        "_expr := {_expr} + {'decr'} -> PostDecr( var=$0 )",
        "_expr := {_expr} + {'incr'} -> PostIncr( var=$0 )",
        "_expr := 'decr' + _expr -> PreDecr( var=$1 )",
        "_expr := 'incr' + _expr -> PreIncr( var=$1 )",
        "_expr := {'sizeof'} + {'sizeof_separator' + sizeof_body} -> SizeOf( var=$1 )",
        "_expr := {_expr} + {'questionmark' + _expr + 'colon' + _expr} -> TernaryOperator( cond=$0, true=$2, false=$4 )",
        "_expr := 'bitand' + _expr -> AddressOf( var=$1 )",
        "_expr := 'asterisk' + _expr -> Dereference( var=$1 )",
        "_expr := _expr + 'add' + _expr -> Add( left=$0, right=$2 )",
        "_expr := _expr + 'sub' + _expr -> Sub( left=$0, right=$2 )",
        "_expr := _expr + 'lt' + _expr -> LessThan( left=$0, right=$2 )",
        "_expr := _expr + 'gt' + _expr -> GreaterThan( left=$0, right=$2 )",
        "_expr := _expr + 'lteq' + _expr -> LessThanEq( left=$0, right=$2 )",
        "_expr := _expr + 'gteq' + _expr -> GreaterThanEq( left=$0, right=$2 )",
        "_expr := _expr + 'asterisk' + _expr -> Mul( left=$0, right=$2 )",
        "_expr := _expr + 'div' + _expr -> Div( left=$0, right=$2 )",
        "_expr := _expr + 'mod' + _expr -> Mod( left=$0, right=$2 )",
        "_expr := _expr + 'eq' + _expr -> Equals( left=$0, right=$2 )",
        "_expr := _expr + 'assign' + _expr -> Assign( var=$0, value=$2 )",
        "_expr := _expr + 'comma' + _expr -> Comma( left=$0, right=$2 )",
        "_expr := _expr + 'lshift' + _expr -> LeftShift( left=$0, right=$2 )",
        "_expr := _expr + 'rshift' + _expr -> RightShift( left=$0, right=$2 )",
        "_expr := _expr + 'bitand' + _expr -> BitAND( left=$0, right=$2 )",
        "_expr := _expr + 'bitor' + _expr -> BitOR( left=$0, right=$2 )",
        "_expr := _expr + 'bitxor' + _expr -> BitXOR( left=$0, right=$2 )",
        "_expr := _expr + 'addeq' + _expr -> AddAssign( left=$0, right=$2 )",
        "_expr := _expr + 'subeq' + _expr -> SubtractAssign( left=$0, right=$2 )",
        "_expr := _expr + 'muleq' + _expr -> MultiplyAssign( left=$0, right=$2 )",
        "_expr := _expr + 'diveq' + _expr -> DivideAssign( left=$0, right=$2 )",
        "_expr := _expr + 'modeq' + _expr -> ModAssign( left=$0, right=$2 )",
        "_expr := _expr + 'bitandeq' + _expr -> ANDAssign( left=$0, right=$2 )",
        "_expr := _expr + 'bitoreq' + _expr -> ORAssign( left=$0, right=$2 )",
        "_expr := _expr + 'bitxoreq' + _expr -> XORAssign( left=$0, right=$2 )",
        "_expr := _expr + 'lshifteq' + _expr -> LeftShiftAssign( left=$0, right=$2 )",
        "_expr := _expr + 'rshifteq' + _expr -> RightShiftAssign( left=$0, right=$2 )",
        "_expr := {'identifier'} | {constant} | {'string_literal'}",
        "_expr := {'lparen' + _expr + 'rparen'} -> $2"
      ]
    },
    {
      "nonterminal": "_direct_abstract_declarator",
      "rules": [
        "_direct_abstract_declarator := {'lparen' + abstract_declarator + 'rparen'}",
        "_direct_abstract_declarator := {direct_abstract_declarator_opt} + {'lsquare' + direct_abstract_declarator_expr + 'rsquare'}",
        "_direct_abstract_declarator := {direct_abstract_declarator_opt} + {'lparen' + parameter_type_list_opt + 'rparen'}"
      ],
      "binding_power": [
          {"associativity": "left", "terminals": ["lsquare", "lparen"]}
      ]
    },
    {
      "nonterminal": "_direct_declarator",
      "rules": [
        "_direct_declarator := {'identifier'}",
        "_direct_declarator := {'lparen' + declarator + 'rparen'} -> $1",
        "_direct_declarator := {_direct_declarator} + {'lsquare' + direct_declarator_expr + 'rsquare'} -> Array(name=$0, size=$2)",
        "_direct_declarator := {_direct_declarator} + {'lparen' + direct_declarator_parameter_list + 'rparen'} -> FunctionSignature(declarator=$0, params=$2)"
      ],
      "binding_power": [
          {"associativity": "left", "terminals": ["lsquare", "lparen"]}
      ]
    }
  ]
}
