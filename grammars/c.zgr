{
  "ll1": {
    "start": "translation_unit",
    "rules": [
      "translation_unit := list(external_declaration) -> TranslationUnit( external_declarations=$0 )",
      "external_declaration :=  'external_declaration_hint' + mlist(declaration_specifier, 1) + external_declaration_sub -> ExternalDeclaration( declaration_specifiers=$1, declarations=$2)",
      "external_declaration_sub := external_function | list(external_declaration_sub_sub, 'comma') + 'semi'",
      "external_declaration_sub_sub := external_declarator | external_prototype",
      "external_function := 'function_definition_hint' + declarator + optional(declaration_list) + compound_statement -> FunctionDefinition( signature=$1, declaration_list=$2, body=$3)",
      "external_declarator := 'declarator_hint' + optional(init_declarator) ->  ExternalDeclarator(init_declarator=$1)",
      "external_prototype := 'function_prototype_hint' + declarator + optional(declaration_list) -> FunctionPrototype(declarator=$1, declaration_list=$2)",
      "declaration_list := list(declaration)",
      "declaration := mlist(declaration_specifier, 1) + optional(init_declarator_list) + 'semi' -> Declaration( declaration_specifiers=$0, init_declarators=$1 )",
      "declaration_specifier := storage_class_specifier | type_specifier | type_qualifier | function_specifier",
      "init_declarator_list := list(init_declarator, 'comma', 1)",
      "init_declarator := declarator + optional(declarator_initializer) -> InitDeclarator( declarator=$0, initializer=$1 )",
      "declarator_initializer := 'assign' + initializer -> $1",
      "initializer := _expr_sans_comma",
      "initializer := 'lbrace' + list(initializer_list_item, 'comma', 1) + trailing_comma_opt + 'rbrace' -> $1",
      "initializer_list_item := optional(designation) + initializer -> Initialization(designation=$0, initializer=$1)",
      "designation := list(designator) + 'assign'",
      "designator := 'lsquare' + _expr + 'rsquare' -> ArrayAccess( index=$1 )",
      "designator := 'dot' + 'identifier' -> MemberAccess( name=$1 )",
      "storage_class_specifier := 'typedef' | 'extern' | 'static' | 'auto' | 'register'",
      "type_specifier := 'void' | 'char' | 'short' | 'int' | 'long' | 'float' | 'double' | 'signed' | 'unsigned' | 'bool' | 'complex' | 'imaginary' | struct_specifier | union_specifier | enum_specifier | typedef_name",
      "struct_specifier := 'struct' + struct_or_union_sub -> Struct( definition=$1 )",
      "union_specifier := 'union' + struct_or_union_sub -> Union( definition=$1 )",
      "struct_or_union_sub := 'identifier' + optional(struct_or_union_body) -> StructOrUnion( name=$0, body=$1 )",
      "struct_or_union_sub := struct_or_union_body -> StructOrUnion( body=$0 )",
      "struct_or_union_body := 'lbrace' + list(struct_declaration) + 'rbrace' -> $1",
      "struct_declaration := list(specifier_qualifier) + list(struct_declarator, 'comma', 1) + 'semi' -> StructOrUnionDeclaration( specifier_qualifiers=$0, declarators=$1 )",
      "specifier_qualifier := type_specifier | type_qualifier",
      "struct_declarator := struct_declarator_body",
      "struct_declarator := declarator + optional(struct_declarator_body)",
      "struct_declarator_body := 'colon' + declarator",
      "enum_specifier := 'enum' + enum_specifier_sub",
      "enum_specifier_sub := identifier + optional(enum_specifier_body)",
      "enum_specifier_sub := enum_specifier_body",
      "enum_specifier_body := 'lbrace' + list(enumerator, 'comma', 1) + trailing_comma_opt + 'rbrace'",
      "enumerator := enumeration_constant  + enumerator_assignment",
      "enumerator_assignment := 'assign' + _expr | _empty",
      "enumeration_constant := 'identifier'",
      "typedef_name := 'typedef_identifier'",
      "type_qualifier := 'const' | 'restrict' | 'volatile'",
      "type_qualifier_list_opt := list(type_qualifier) | _empty",
      "function_specifier := 'inline'",
      "declarator := optional(pointer) + _direct_declarator -> Declarator( pointer=$0, direct_declarator=$1 )",
      "direct_declarator_expr := direct_declarator_modifier_list_opt + direct_declarator_size | _empty",
      "direct_declarator_modifier_list_opt := list(direct_declarator_modifier) | _empty",
      "direct_declarator_modifier := type_qualifier | 'static'",
      "direct_declarator_size := _expr | 'variable_length_array'",
      "parameter_type_list := list(parameter_declaration, 'comma', 1) + optional(va_args) -> ParameterTypeList( parameter_declarations=$0, va_args=$1 )",
      "direct_declarator_parameter_list := parameter_type_list | list(identifier, 'comma') -> ParameterList( identifiers=$0 ) | _empty",
      "identifier := 'identifier'",
      "va_args := 'comma_va_args' + 'elipsis' -> $1",
      "parameter_declaration := named_parameter_declaration | abstract_parameter_declaration",
      "named_parameter_declaration := 'named_parameter_hint' + mlist(declaration_specifier, 1) + optional(declarator) -> NamedParameter( declaration_specifiers=$1, declarator=$2 )",
      "abstract_parameter_declaration := 'abstract_parameter_hint' + mlist(declaration_specifier, 1) + optional(abstract_declarator) -> AbstractParameter(declaration_specifiers=$1, declarator=$2)",
      "abstract_declarator := _direct_abstract_declarator",
      "abstract_declarator := pointer + optional(_direct_abstract_declarator)",
      "pointer := mlist(pointer_sub, 1)",
      "pointer_sub := 'asterisk' + type_qualifier_list_opt",
      "direct_abstract_declarator_expr := type_qualifier_list_opt + static_opt + _expr | 'variable_length_array' | _empty",
      "expression_opt := _expr | _empty",

      "statement := labeled_statement",
      "statement := compound_statement",
      "statement := expression_statement",
      "statement := selection_statement",
      "statement := iteration_statement",
      "statement := jump_statement",
      "labeled_statement := 'label_hint' + 'identifier' + 'colon' + statement -> Label( name=$0, statement=$1)",
      "labeled_statement := 'case' + _expr + 'colon' + statement -> Case( expr=$1, statement=$3 )",
      "labeled_statement := 'default' + 'colon' + statement -> DefaultCase( statement=$2 )",
      "compound_statement := 'lbrace' + optional(block_item_list) + 'rbrace' -> $1",
      "block_item_list := list(block_item)",
      "block_item := declaration | statement",
      "expression_statement := expression_opt + 'semi'",
      "selection_statement := 'if' + 'lparen' + _expr + 'rparen' + statement + 'endif' + optional(else_if_statement_list) + optional(else_statement) -> If(condition=$2, statement=$4, elseif=$6, else=$7)",
      "else_if_statement_list := list(else_if_statement)",
      "else_if_statement := 'else_if' + 'lparen' + _expr + 'rparen' + statement + 'endif' -> ElseIf( condition=$2, statement=$4 )",
      "else_statement := 'else' + statement + 'endif' -> Else( statement=$1 )",
      "selection_statement := 'switch' + 'lparen' + _expr + 'rparen' + statement -> Switch( expr=$2, statment=$4 )",
      "iteration_statement := 'while' + 'lparen' + _expr + 'rparen' + statement -> While( expr=$2, statement=$4 )",
      "iteration_statement := 'do' + statement + 'while' + 'lparen' + _expr + 'rparen' + 'semi' -> DoWhile( statement=$1, expr=4 )",
      "iteration_statement := 'for' + 'lparen' + for_init + for_cond + for_incr + 'rparen' + statement -> For( init=$2, cond=$3, incr=$4, statement=$6 )",
      "for_init := declaration + expression_opt | _expr | _empty",
      "for_cond := 'semi' + expression_opt -> $1",
      "for_incr := 'semi' + expression_opt -> $1 | _empty",
      "jump_statement := 'goto' + 'identifier' + 'semi' -> Goto( name=$1 )",
      "jump_statement := 'continue'",
      "jump_statement := 'break' + 'semi'",
      "jump_statement := 'return' + expression_opt + 'semi' -> Return( expr=$1 )",


      "pp := 'defined' | 'defined_separator' | 'pp_number'",
      "token := keyword | 'identifier' | constant | 'string_literal' | punctuator | 'pp_number'",
      "keyword := 'auto' | 'break' | 'case' | 'char' | 'const' | 'continue' | 'default' | 'do' | 'double' | 'else' | 'enum' | 'extern' | 'float' | 'for' | 'goto' | 'if' | 'inline' | 'int' | 'long' | 'register' | 'restrict' | 'return' | 'short' | 'signed' | 'sizeof' | 'static' | 'struct' | 'switch' | 'typedef' | 'union' | 'unsigned' | 'void' | 'volatile' | 'while' | 'bool' | 'complex' | 'imaginary'",
      "punctuator := 'arrow' | 'dot' | 'lbrace' | 'rbrace' | 'lsquare' | 'rsquare' | 'lparen' | 'rparen' | 'exclamation_point' | 'tilde' | 'sub' | 'add' | 'div' | 'ampersand' | 'decr' | 'incr' | 'or' | 'and' | 'bitor' | 'bitxor' | 'neq' | 'eq' | 'lteq' | 'gteq' | 'lt' | 'gt' | 'lshift' | 'rshift' | 'mod' | 'elipsis' | 'semi' | 'colon' | 'questionmark' | 'bitoreq' | 'bitxoreq' | 'bitandeq' | 'lshifteq' | 'rshifteq' | 'subeq' | 'addeq' | 'modeq' | 'muleq' | 'assign' | 'poundpound' | 'pound' | 'comma'",

      "constant := 'integer_constant' | 'floating_constant' | 'enumeration_constant' | 'character_constant' | 'decimal_floating_constant' | 'hexadecimal_floating_constant'",
      "type_name := 'int' | 'char'",
      "trailing_comma_opt := 'trailing_comma' | _empty",
      "static_opt := 'static' | _empty",
      "sizeof_body := 'identifier' | 'lparen' + type_name + 'rparen' -> $1",
      "misc := 'universal_character_name' | 'endif'"
    ]

  },
  "expr": [
    {
      "nonterminal": "_expr",
      "extends": "_expr_sans_comma",
      "binding_power": [
          {"associativity": "left", "terminals": ["comma"]}
      ],
      "rules": [
        "_expr := _expr + 'comma' + _expr -> Comma( left=$0, right=$2 )"
      ]
    },
    {
      "nonterminal": "_expr_sans_comma",
      "binding_power": [
          {"associativity": "right", "terminals": ["assign", "addeq", "subeq", "muleq", "diveq", "modeq", "bitoreq", "bitandeq", "bitxoreq", "lshifteq", "rshifteq"]},
          {"associativity": "right", "terminals": ["questionmark"]},
          {"associativity": "left", "terminals": ["or"]},
          {"associativity": "left", "terminals": ["and"]},
          {"associativity": "left", "terminals": ["bitand"]},
          {"associativity": "left", "terminals": ["bitxor"]},
          {"associativity": "left", "terminals": ["bitor"]},
          {"associativity": "right", "terminals": ["eq", "neq"]},
          {"associativity": "left", "terminals": ["lt", "gt", "gteq", "lteq"]},
          {"associativity": "left", "terminals": ["lshift", "rshift"]},
          {"associativity": "left", "terminals": ["add", "sub"]},
          {"associativity": "left", "terminals": ["asterisk", "div", "mod"]},
          {"associativity": "unary", "terminals": ["sub", "incr", "decr", "asterisk", "bitand", "not", "bitnot"]},
          {"associativity": "left", "terminals": ["lbrace"]},
          {"associativity": "left", "terminals": ["lparen", "dot", "lsquare", "arrow", "incr", "decr"]}
      ],
      "rules": [
        "_expr_sans_comma := {'identifier'} + {'lparen' + list(_expr_sans_comma, 'comma') + 'rparen'} -> FuncCall( name=$0, params=$2 )",
        "_expr_sans_comma := {'identifier'} + {'lsquare' + list(_expr_sans_comma, 'comma') + 'rsquare'} -> ArrayIndex( name=$0, params=$2 )",
        "_expr_sans_comma := {'lparen_cast' + type_name + 'rparen'} + {'lbrace' + list(initializer_list_item, 'comma') + trailing_comma_opt + 'rbrace'} -> TypeInitializion( type=$1, initializer=$4 )",
        "_expr_sans_comma := {_expr_sans_comma} + {'dot' + _expr_sans_comma} -> MemberSelect( object=$0, member=$2 )",
        "_expr_sans_comma := {_expr_sans_comma} + {'arrow' + _expr_sans_comma} -> DerefMemberSelect( object=$0, member=$2 )",
        "_expr_sans_comma := {_expr_sans_comma} + {'decr'} -> PostDecr( var=$0 )",
        "_expr_sans_comma := {_expr_sans_comma} + {'incr'} -> PostIncr( var=$0 )",
        "_expr_sans_comma := 'decr' + _expr_sans_comma -> PreDecr( var=$1 )",
        "_expr_sans_comma := 'incr' + _expr_sans_comma -> PreIncr( var=$1 )",
        "_expr_sans_comma := {'sizeof'} + {'sizeof_separator' + sizeof_body} -> SizeOf( var=$1 )",
        "_expr_sans_comma := {_expr_sans_comma} + {'questionmark' + _expr_sans_comma + 'colon' + _expr_sans_comma} -> TernaryOperator( cond=$0, true=$2, false=$4 )",
        "_expr_sans_comma := 'bitand' + _expr_sans_comma -> AddressOf( var=$1 )",
        "_expr_sans_comma := 'asterisk' + _expr_sans_comma -> Dereference( var=$1 )",
        "_expr_sans_comma := _expr_sans_comma + 'add' + _expr_sans_comma -> Add( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'sub' + _expr_sans_comma -> Sub( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'lt' + _expr_sans_comma -> LessThan( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'gt' + _expr_sans_comma -> GreaterThan( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'lteq' + _expr_sans_comma -> LessThanEq( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'gteq' + _expr_sans_comma -> GreaterThanEq( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'asterisk' + _expr_sans_comma -> Mul( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'div' + _expr_sans_comma -> Div( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'mod' + _expr_sans_comma -> Mod( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'eq' + _expr_sans_comma -> Equals( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'assign' + _expr_sans_comma -> Assign( var=$0, value=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'lshift' + _expr_sans_comma -> LeftShift( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'rshift' + _expr_sans_comma -> RightShift( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'bitand' + _expr_sans_comma -> BitAND( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'bitor' + _expr_sans_comma -> BitOR( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'bitxor' + _expr_sans_comma -> BitXOR( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'addeq' + _expr_sans_comma -> AddAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'subeq' + _expr_sans_comma -> SubtractAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'muleq' + _expr_sans_comma -> MultiplyAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'diveq' + _expr_sans_comma -> DivideAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'modeq' + _expr_sans_comma -> ModAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'bitandeq' + _expr_sans_comma -> ANDAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'bitoreq' + _expr_sans_comma -> ORAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'bitxoreq' + _expr_sans_comma -> XORAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'lshifteq' + _expr_sans_comma -> LeftShiftAssign( left=$0, right=$2 )",
        "_expr_sans_comma := _expr_sans_comma + 'rshifteq' + _expr_sans_comma -> RightShiftAssign( left=$0, right=$2 )",
        "_expr_sans_comma := {'identifier'} | {constant} | {'string_literal'}",
        "_expr_sans_comma := {'lparen' + _expr_sans_comma + 'rparen'} -> $2"
      ]
    },
    {
      "nonterminal": "_direct_declarator",
      "rules": [
        "_direct_declarator := {'identifier'}",
        "_direct_declarator := {'lparen' + declarator + 'rparen'} -> $1",
        "_direct_declarator := {_direct_declarator} + {'lsquare' + direct_declarator_expr + 'rsquare'} -> Array(name=$0, size=$2)",
        "_direct_declarator := {_direct_declarator} + {'lparen' + direct_declarator_parameter_list + 'rparen'} -> FunctionSignature(declarator=$0, params=$2)"
      ],
      "binding_power": [
          {"associativity": "left", "terminals": ["lsquare", "lparen"]}
      ]
    },
    {
      "nonterminal": "_direct_abstract_declarator",
      "rules": [
        "_direct_abstract_declarator := {'lparen' + abstract_declarator + 'rparen'} -> $1",
        "_direct_abstract_declarator := {optional(_direct_abstract_declarator)} + {'lsquare' + direct_abstract_declarator_expr + 'rsquare'} -> AbstractArray( object=$$, size=$2 )",
        "_direct_abstract_declarator := {optional(_direct_abstract_declarator)} + {'lparen' + optional(parameter_type_list) + 'rparen'} -> AbstractFunction( object=$$, params=$2 )"
      ],
      "binding_power": [
          {"associativity": "left", "terminals": ["lsquare", "lparen"]},
          {"associativity": "unary", "terminals": ["lparen"]}
      ]
    }
  ]
}
